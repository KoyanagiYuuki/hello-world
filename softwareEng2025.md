# ソフトウェア工学

ソフトウェア工学とは,「**品質**」,「**コスト**」,「**納期**」の3つの最適なバランスを実現するために行う手法,方法論のことである.

>## ソフトウェア工学概論
>>### ソフトウェアの定義
>>1. 実行することで必要な特性,機能,性能,を提供する命令語群(コンピュータプログラム)
>>2. プログラムが適切に情報を扱うことが可能となるデータ構造
>>3. プログラムの操作方法や使用方法を適切に記述した情報
>
>
>>### ソフトウェアの特徴
>>- 新しい環境や技術のニーズを満たすために適応していく必要がある.
>>- 新しいビジネス要求を実現していくために強化していく必要がある.
>>- より近代的なシステムやデータベースと相互運用していくために拡張していく必要がある.
>>- 進化し続ける環境においても実行可能となるように,再構築していく必要がある.
>
>
>>### プラクティスの本質
>>1. 問題の理解(コミュニケーションと分析)
>>2. 解決策の計画(モデリングとソフトウェア設計)
>>3. 計画の実行(コードの実装)
>>4. 結果の正しさを理解する(テストと品質保証)
>
>
>>### Hookerの7原則
>>1. システムはユーザに価値を提供するために存在している.
>>2. すべての設計は可能な限りシンプルに.
>>3. ソフトウェアプロジェクトの成功には明確なビジョンを持つことが必要.
>>4. 自分が作ったものを他人が理解しなければいけないということを常に考え,仕様の決定,設計,ドキュメントを作成し,実装するべき.
>>5. 環境の変化に備え,可能な限り多くの選択肢を与えられるように準備しておく.
>>6. コストを低減し,再利用するコンポーネントとそれを取り込むシステムの両方の価値を高める.
>>7. 行動を起こす前に簡潔明瞭な考えを持つことで,良い結果を生む可能性が高くなる.
>
>
>>### ソフトウェア工学の必要性
>>1. 大規模化と複雑さ<br>
ソフトウェアは社会を支える基盤であるため,ソフトウェアを効率よく開発,メンテナンスを行う必要がある.そのために部品化,オブジェクト化を用いて,効率と品質の両立を行う.
>>2. IT人材の不足<br>
現状,ソフトウェアの需要に対してIT人材が足りないという量的問題と,ソフトウェアを効率的に開発,管理することの可能な人材の低下という質的問題の二つの問題点がある.
>>3. 社会性と求められるミッション<br>
ライフラインやインフラストラクチャーとしてのソフトウェアが増加したため,不測の事態に対応した事業,サービスの継続が求められるように.
>>4. 不確実性の増加<br>
検索型から交流型に変わり,意図しないソフトウェアの活用が増加するなど,ソフトウェアの利用方法が変化し,多様化している.そのためにもニーズに対応したソフトウェアの開発が求められる.
>
>
>>### Hyrumの法則
>>___
>>あるAPIに十分な数のユーザがいるとき,APIを作成した者自身が契約仕様として何を約束しているかは重要ではない.作成されたシステムが持つあらゆる観察可能な挙動に対して,それに依存するユーザは出てくる.
>>___
>>->つまりユーザはソフトウェアを自由な使い方で利用することが可能である.
>
>
>>### スケーラブルなソフトウェア
>>「変更すべき全てのものを安全に変更可能で、かつコードベースの存続期間を通してそれが可能であるとき、組織のコードベースは持続可能である」<br><br>
>>着想段階から設計,開発,テスト,コミット,インテグレーション,そして本番環境へと流れるにつれて,そこにかかるコストは二次関数的に増加する.
>
>
>>### コストの種類
>>- 財務コスト(資金など)
>>- 資源コスト(CPU時間など)
>>- 人権コスト(エンジニアリング労力)
>>- 処理コスト(行動に伴うコスト)
>>- 機会コスト(行動を取らない場合のコスト)
>>- 社会コスト(社会に対する影響)
>
>### ソフトウェア工学の目標とは
>**ソフトウェアシステムが変化し続ける状況に対応する方法論**を考え出すことである.新しいソフトウェアが古いシステムから構築されて,すべて互換性を持ち,他システムと相互運用される必要がある.<br>
>#
<br>

>## ソフトウェアライフサイクル
>ソフトウェアが誕生に至るまでには様々な工程が存在している.まずはニーズが発生し,それに伴いビジネス上あるいはシステム上の要求を具現化するための企画・計画を行う.次にどのようなソフトウェアにするか,そのソフトウェアによる影響などをまとめた要件定義書を作成する.その後にソフトウェアの開発がなされ,実稼働,保守運用などが行われる.ソフトウェアの廃止が決まれば,サービスを停止し,新しいソフトウェアへリニューアルする場合もある.
>>### 要件定義
>>要件定義では,実現する機能と実現しない機能を明確に記述しておく必要がある.以下は要件定義に記述されるものの例である.
>>___
>>- システムの目的
>>- システムの概要
>>- システムの機能
>>- システムの構成(システム構成図など)
>>- 目標性能
>>- 他システムとのインタフェース仕様
>>- 運用面の注意事項
>>- 制限事項
>>- 拡張性
>>- 開発スケジュール
>>- 開発体制
>>- 納品物
>>___
>
>>### 要件定義の意義
>>- プロジェクト関係者のバイブル
>>      - スコープを共有する
>>- 社内外への宣言と協力の依頼
>>      - プロジェクトの内容を文章として明示し,協力を要請する.
>>- Request for Proposal(RFP)
>>      - ベンダーに具体的なシステム提案を依頼するために作成する文書.
>
>>### 設計
>>要件定義書から設計書を作成し,コーディングができるレベルまで仕様書に落とし込んでいく.ここではプロジェクトを細分化し,構造的に整理した構成図であるWBS(Work Breakdown Structure)を用いる.
>
>>### 製作
>>設計書に基づいてシステムを構築していく.
>>- 内製(自社開発)
>>      - 一部機能に関してはパッケージを購入したり,外部委託して構築することもある.
>>- 調達(外部委託)
>>      - 開発を外部に委託する.
>>      - ソースコートを納品物に含める場合,メンテナンスは自社で行うことが可能.
>>      - ソースコードを納品物に含めない場合,メンテナンスに関して作業委託契約を締結する必要がある.
>
>>### オフショア開発
>>___
>>- 賃金の安い海外企業に外部委託する手法.
>>- 注意事項として,文化の違い,言語の違い,商習慣の違い,品質に対する意識の違いが存在する.<br>
>>___
>>昔は海外企業の賃金が安かったが,今後は日本のIT企業がオフショア開発される側になる可能性がある.
>
>>### テストとデバッグ
>>バグのないソフトウェアは存在しないと考えるべきであり,あらかじめテストを行い,バグの早期発見,対処をすることが理想ではあるが,すべてをテストすることは工数からみても不可能に近い.そのため,ソフトウェアのどこをテストするのか,どの程度テストするのかを慎重に見定める必要がある.
>
>>### 運用・保守
>>- 稼働後のデータを積極的に活用していくべき.
>>- ソフトウェア以外の要因も考慮する必要がある.
>>- 開発者がそのプロジェクトから離れている可能性がある.
>
>>### ドキュメンテーション
>>複数人でソフトウェア開発をする際には,文書でのコミュニケーションのように,非同期なコミュニケーションのが非常に重要となる.しかし,文書は日本語とは限らないため注意が必要.例えば,海外企業とのプロジェクトが増える可能性もある.そもそもIT技術のほとんどが海外で生まれたものであるため,マニュアルやエラーメッセージなどが日本語で表示されることはほとんどない.だいたいが英語である.<br>
>#
<br>

>## プロジェクト
>プロジェクトは,必ず終わりがあるという有期性と,独自の目的を達成するという独自性の二つを内包している.<br>
>>### フォアキャスティングとバックキャスティング
>>- フォアキャスティング
>>      - どれ程行ったかというインプット視点で,今の立ち位置から順に目標へ進んでいく.
>>      - 目標に到達できなかったり,目標から遠く離れたところに到達する可能性がある.
>>- バックキャスティング
>>      - 何を成し遂げるかというアウトプット視点で,定めた目標に向けて何が必要かを計画し行動する.
>>      - 明確な目標の設定や,目標に向けた計画を立てる必要がある.
>>      - 目標とそれに向けた筋道は適宜修正可能であり,具体的かつ達成する価値のあるものがよい.
># 
<br>

>## ソフトウェア分析
>>### ソフトウェアの見える化
>>___
>>- ソフトウェアの物量に関する分析
>>- ソフトウェアの実行性能に関する分析
>>- ソフトウェアの開発工数に関する分析
>>- ソフトウェアの品質に関する分析
>>___
>>品質(quality),コスト(Cost),納期(Delivery)の頭文字を合わせてQCDと略されるが,これらの分析はQCDの優先度を決定する際に利用される.
>>- 品質優先：人命に関わるシステム
>>- 費用優先：公共関連システム
>>- 納期優先：イベントや行事関連のシステム
>
>>### ソフトウェアの品質管理
>>計画していたテストではすべてバグに対応したが,他のバグがまだ確認されていないときは「Hyrumの法則」を想定するべきである.
またリリースにおいても,バグを最小化した状態でリリースするか,リリース後にバグに対応するかは,同様の法則を想定すべきである.
>
>>### バグ発生率
>>バグ発生率とは1ステップ数(改行を除いたコードの行数)あたりのバグ発生数である.ここで以下のような場合を考える.<br><br>
>>100ステップのソフトウェアに100のテストを実施し,10件のバグを発見<br>
>>-> バグ発生率1 = 10件 / 100ステップ = 0.1 件/ステップ<br>
>>追加で50のテストを実施し,5件のバグを発見<br>
>>-> バグ発生率2 = 15件 / 100ステップ = 0.15 件/ステップ<br>
>><br>
>>ここから考えると,一見追加テストを行ったほうがバグ発生率が高いので,品質が悪くなってしまうのではないかと思われるが,バグ発生率はソフトウェア品質評価の1指標であるため,これだけで品質の良し悪しを決定することはできない.
>
>>### ソフトウェアの評価
>>ソフトウェアの評価とはその価値を測ることである.<br>
>>1. コードの物量<br>
>>例えばc言語換算のソースコード行数など.複数言語が入り混じっている場合には換算する必要がある.
>>2. コードの物量)(オブジェクト容量)<br>
>>特に組み込み型ソフトウェアはサイズが小さい程良いとされる.
>>3. ファンクションポイント法(FP法)<br>
>>プログラミングのフェーズに入る前に,ユーザ要件が定まり,必要な機能が見えてきた段階で,ある程度のシステムの規模を概算することが可能.
>>4. 使い勝手<br>
>>      1. 画面の視認性
>>      2. 操作性
>>      3. 入力補助
>>      4. 互換性
>>      5. チュートリアル
># 
<br>

>## 開発プロセス
>>### ウォーターフォール型開発プロセス
>>- 要件定義が完成したら機能設計,機能設計が完成したら詳細設計といったように順々にこなしていくため,進捗管理が容易で,成果物が明確である.
>>- 計画通りにいかなかった部分は,後工程にしわ寄せが集中してしまうリスクがある.
>
>>### スパイラルモデル
>>- プログラム開発を小さなフェーズに分割して行う.
>>- フェーズごとにプロトタイプ,提案,評価,フィードバックの4つの工程を繰り返す.
>>- プロトタイプを作成する際に,想定外の作業量を伴う可能性がある.
>
>>### 反復型開発プロセス
>>ソフトウェアを機能ごとに分割して,それらを反復という単位で管理する手法.<br>
>>- メリットとして,部分的に完成させていくため,顧客の要求に対応しやすい.また部分的に納品することも可能.<br>
>>- デメリットとして,作業や管理業務の増加,全体像の見えづらさ,一括して稼働するシステムでは意味がないなどが挙げられる.
>
>>### アジャイルプロセス
>>アジャイル(agile)とは機敏,俊敏といったように,ウォーターフォール型開発プロセスでは想定されていなかった,できるだけ決定を遅らせ,できるだけ早く提供するということを実現したモデル.変化に対応し,最適な手法で動作するソフトウェアの提供を優先,またモチベーションを上げ,学習効果を高めることで無駄をなくしている.<br>
>>#### アジャイルの価値
>>- プロセスやツールよりも個人の相互作用.
>>- 分かりやすいドキュメントよりも,動作するソフトウェア.
>>- 契約上の駆け引きよりも,顧客と協力して共に進めていく.
>>- 計画通りではなく,変化に対応.
>>#### アジャイルのコンセプト
>>- 変化に対する柔軟性.
>>- 俊敏なサイクル,頻繁な納期.
>>- シンプルさ
>>- リファクタリング
>>- ペアプログラミング
>>- レトロスペクティブ
>>- 暗黙知の活用
>>- テスト駆動型開発
>
>>### アジャイル開発の12の原則
>>1. ソフトウェアの早期,継続的な納品によって顧客の満足度を達することが最優先である.
>>2. いついかなる時も要求内容の変更を歓迎する.アジャイルなプロセスは顧客の競争上の優位性のために変化を制する.
>>3. 数週間から数ヵ月といったように,短いサイクルでソフトウェアを納品する.
>>4. ビジネス側の人間も,開発者も日々協力してプロジェクトを進めなければならない.
>>5. 志の高い人間がチームの中心となりプロジェクトを編成する.必要な環境や資源を与え,任務をやり遂げることを信じること.
>>6. 開発チームの内外で情報伝達を行う際には,顔を突き合わせることが最も効率的で効果的である.
>>7. 動作するソフトウェアが主な進捗確認の方法である.
>>8. アジャイルなソフトウェア開発は,持続的な開発を促す.開発資金の提供者,開発者,ユーザは,必ず一定のペースを守るべきである.
>>9. 機敏さ向上のために,技術力とよい設計に絶えず気を配ること.
>>10. その本質には,不必要なことは行わないという簡潔さが存在している.
>>11. 最新のアーキテクチャ,要求,設計は,自己組織化されたチームから生まれる.
>>12. 定期的に,チームでもっと効率的になる道を考え,開発の進み方を見直し,調整する.<br>
>### どの開発手法がよいのか
>開発手法それぞれにメリットデメリットは存在しており,一長一短である.場面,要求からもっとも適した手法を用いることが重要である.
<br>

>## WBS(Work Breakdown Structure)
>WBSとは,プロジェクトの目標を達成し,必要な要素成果物を生成するために,プロジェクトチームが実行すべき作業をあらかじめ階層的に要素分解したものである.
>#### メリット
>- スコープが明確になる.
>- やるべき作業が明確になる.
>- 全体管理と作業計画が明確化される.
>- プロジェクトを実行する際は,WBSに従って実行するのみ.
>>### WBSの作り方
>>- トップダウンアプローチとバックキャスティングからスコープを明確にする.
>>- 大きな作業は分割し,グループごとにまとめる.
>>- グルーピングした作業の相互関連を考える.
>>- もれなくダブりなく各グループの作業を全て洗い出す.
># 