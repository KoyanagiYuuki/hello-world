---
layout: page
title: "Software Eng. lecture note
permalink: /docs/softwareEng2025
---

# ソフトウェア工学

ソフトウェア工学とは,「**品質**」,「**コスト**」,「**納期**」の3つの最適なバランスを実現するために行う手法,方法論のことである.

>## ソフトウェア工学概論
>>### ソフトウェアの定義
>>1. 実行することで必要な特性,機能,性能,を提供する命令語群(コンピュータプログラム)
>>2. プログラムが適切に情報を扱うことが可能となるデータ構造
>>3. プログラムの操作方法や使用方法を適切に記述した情報
>
>
>>### ソフトウェアの特徴
>>- 新しい環境や技術のニーズを満たすために適応していく必要がある.
>>- 新しいビジネス要求を実現していくために強化していく必要がある.
>>- より近代的なシステムやデータベースと相互運用していくために拡張していく必要がある.
>>- 進化し続ける環境においても実行可能となるように,再構築していく必要がある.
>
>
>>### プラクティスの本質
>>1. 問題の理解(コミュニケーションと分析)
>>2. 解決策の計画(モデリングとソフトウェア設計)
>>3. 計画の実行(コードの実装)
>>4. 結果の正しさを理解する(テストと品質保証)
>
>
>>### Hookerの7原則
>>1. システムはユーザに価値を提供するために存在している.
>>2. すべての設計は可能な限りシンプルに.
>>3. ソフトウェアプロジェクトの成功には明確なビジョンを持つことが必要.
>>4. 自分が作ったものを他人が理解しなければいけないということを常に考え,仕様の決定,設計,ドキュメントを作成し,実装するべき.
>>5. 環境の変化に備え,可能な限り多くの選択肢を与えられるように準備しておく.
>>6. コストを低減し,再利用するコンポーネントとそれを取り込むシステムの両方の価値を高める.
>>7. 行動を起こす前に簡潔明瞭な考えを持つことで,良い結果を生む可能性が高くなる.
>
>
>>### ソフトウェア工学の必要性
>>1. 大規模化と複雑さ<br>
ソフトウェアは社会を支える基盤であるため,ソフトウェアを効率よく開発,メンテナンスを行う必要がある.そのために部品化,オブジェクト化を用いて,効率と品質の両立を行う.
>>2. IT人材の不足<br>
現状,ソフトウェアの需要に対してIT人材が足りないという量的問題と,ソフトウェアを効率的に開発,管理することの可能な人材の低下という質的問題の二つの問題点がある.
>>3. 社会性と求められるミッション<br>
ライフラインやインフラストラクチャーとしてのソフトウェアが増加したため,不測の事態に対応した事業,サービスの継続が求められるように.
>>4. 不確実性の増加<br>
検索型から交流型に変わり,意図しないソフトウェアの活用が増加するなど,ソフトウェアの利用方法が変化し,多様化している.そのためにもニーズに対応したソフトウェアの開発が求められる.
>
>
>>### Hyrumの法則
>>___
>>あるAPIに十分な数のユーザがいるとき,APIを作成した者自身が契約仕様として何を約束しているかは重要ではない.作成されたシステムが持つあらゆる観察可能な挙動に対して,それに依存するユーザは出てくる.
>>___
>>->つまりユーザはソフトウェアを自由な使い方で利用することが可能である.
>
>
>>### スケーラブルなソフトウェア
>>「変更すべき全てのものを安全に変更可能で、かつコードベースの存続期間を通してそれが可能であるとき、組織のコードベースは持続可能である」<br><br>
>>着想段階から設計,開発,テスト,コミット,インテグレーション,そして本番環境へと流れるにつれて,そこにかかるコストは二次関数的に増加する.
>
>
>>### コストの種類
>>- 財務コスト(資金など)
>>- 資源コスト(CPU時間など)
>>- 人権コスト(エンジニアリング労力)
>>- 処理コスト(行動に伴うコスト)
>>- 機会コスト(行動を取らない場合のコスト)
>>- 社会コスト(社会に対する影響)
>
>### ソフトウェア工学の目標とは
>**ソフトウェアシステムが変化し続ける状況に対応する方法論**を考え出すことである.新しいソフトウェアが古いシステムから構築されて,すべて互換性を持ち,他システムと相互運用される必要がある.<br>
>#
<br>

>## ソフトウェアライフサイクル
>ソフトウェアが誕生に至るまでには様々な工程が存在している.まずはニーズが発生し,それに伴いビジネス上あるいはシステム上の要求を具現化するための企画・計画を行う.次にどのようなソフトウェアにするか,そのソフトウェアによる影響などをまとめた要件定義書を作成する.その後にソフトウェアの開発がなされ,実稼働,保守運用などが行われる.ソフトウェアの廃止が決まれば,サービスを停止し,新しいソフトウェアへリニューアルする場合もある.
>>### 要件定義
>>要件定義では,実現する機能と実現しない機能を明確に記述しておく必要がある.以下は要件定義に記述されるものの例である.
>>___
>>- システムの目的
>>- システムの概要
>>- システムの機能
>>- システムの構成(システム構成図など)
>>- 目標性能
>>- 他システムとのインタフェース仕様
>>- 運用面の注意事項
>>- 制限事項
>>- 拡張性
>>- 開発スケジュール
>>- 開発体制
>>- 納品物
>>___
>
>>### 要件定義の意義
>>- プロジェクト関係者のバイブル
>>      - スコープを共有する
>>- 社内外への宣言と協力の依頼
>>      - プロジェクトの内容を文章として明示し,協力を要請する.
>>- Request for Proposal(RFP)
>>      - ベンダーに具体的なシステム提案を依頼するために作成する文書.
>
>>### 設計
>>要件定義書から設計書を作成し,コーディングができるレベルまで仕様書に落とし込んでいく.ここではプロジェクトを細分化し,構造的に整理した構成図であるWBS(Work Breakdown Structure)を用いる.
>
>>### 製作
>>設計書に基づいてシステムを構築していく.
>>- 内製(自社開発)
>>      - 一部機能に関してはパッケージを購入したり,外部委託して構築することもある.
>>- 調達(外部委託)
>>      - 開発を外部に委託する.
>>      - ソースコートを納品物に含める場合,メンテナンスは自社で行うことが可能.
>>      - ソースコードを納品物に含めない場合,メンテナンスに関して作業委託契約を締結する必要がある.
>
>>### オフショア開発
>>___
>>- 賃金の安い海外企業に外部委託する手法.
>>- 注意事項として,文化の違い,言語の違い,商習慣の違い,品質に対する意識の違いが存在する.<br>
>>___
>>昔は海外企業の賃金が安かったが,今後は日本のIT企業がオフショア開発される側になる可能性がある.
>
>>### テストとデバッグ
>>**バグのないソフトウェアは存在しない**と考えるべきであり,あらかじめテストを行い,バグの早期発見,対処をすることが理想ではあるが,すべてをテストすることは工数からみても不可能に近い.そのため,ソフトウェアのどこをテストするのか,どの程度テストするのかを慎重に見定める必要がある.
>
>>### 運用・保守
>>- 稼働後のデータを積極的に活用していくべき.
>>- ソフトウェア以外の要因も考慮する必要がある.
>>- 開発者がそのプロジェクトから離れている可能性がある.
>
>>### ドキュメンテーション
>>複数人でソフトウェア開発をする際には,文書でのコミュニケーションのように,非同期なコミュニケーションのが非常に重要となる.しかし,文書は日本語とは限らないため注意が必要.例えば,海外企業とのプロジェクトが増える可能性もある.そもそもIT技術のほとんどが海外で生まれたものであるため,マニュアルやエラーメッセージなどが日本語で表示されることはほとんどない.だいたいが英語である.<br>
>#
<br>

>## プロジェクト
>プロジェクトは,必ず終わりがあるという**有期性**と,独自の目的を達成するという**独自性**の二つを内包している.<br>
>>### フォアキャスティングとバックキャスティング
>>- フォアキャスティング
>>      - どれ程行ったかというインプット視点で,今の立ち位置から順に目標へ進んでいく.
>>      - 目標に到達できなかったり,目標から遠く離れたところに到達する可能性がある.
>>- バックキャスティング
>>      - 何を成し遂げるかというアウトプット視点で,定めた目標に向けて何が必要かを計画し行動する.
>>      - 明確な目標の設定や,目標に向けた計画を立てる必要がある.
>>      - 目標とそれに向けた筋道は適宜修正可能であり,具体的かつ達成する価値のあるものがよい.
># 
<br>

>## ソフトウェア分析
>>### ソフトウェアの見える化
>>___
>>- ソフトウェアの物量に関する分析
>>- ソフトウェアの実行性能に関する分析
>>- ソフトウェアの開発工数に関する分析
>>- ソフトウェアの品質に関する分析
>>___
>>品質(quality),コスト(Cost),納期(Delivery)の頭文字を合わせてQCDと略されるが,これらの分析はQCDの優先度を決定する際に利用される.
>>- 品質優先：人命に関わるシステム
>>- 費用優先：公共関連システム
>>- 納期優先：イベントや行事関連のシステム
>
>>### ソフトウェアの品質管理
>>計画していたテストではすべてバグに対応したが,他のバグがまだ確認されていないときは「Hyrumの法則」を想定するべきである.
またリリースにおいても,バグを最小化した状態でリリースするか,リリース後にバグに対応するかは,同様の法則を想定すべきである.
>
>>### バグ発生率
>>バグ発生率とは1ステップ数(改行を除いたコードの行数)あたりのバグ発生数である.ここで以下のような場合を考える.<br><br>
>>100ステップのソフトウェアに100のテストを実施し,10件のバグを発見<br>
>>-> バグ発生率1 = 10件 / 100ステップ = 0.1 件/ステップ<br>
>>追加で50のテストを実施し,5件のバグを発見<br>
>>-> バグ発生率2 = 15件 / 100ステップ = 0.15 件/ステップ<br>
>><br>
>>ここから考えると,一見追加テストを行ったほうがバグ発生率が高いので,品質が悪くなってしまうのではないかと思われるが,バグ発生率はソフトウェア品質評価の1指標であるため,これだけで品質の良し悪しを決定することはできない.
>
>>### ソフトウェアの評価
>>ソフトウェアの評価とはその価値を測ることである.<br>
>>1. コードの物量<br>
>>例えばc言語換算のソースコード行数など.複数言語が入り混じっている場合には換算する必要がある.
>>2. コードの物量(オブジェクト容量)<br>
>>特に組み込み型ソフトウェアはサイズが小さい程良いとされる.
>>3. ファンクションポイント法(FP法)<br>
>>プログラミングのフェーズに入る前に,ユーザ要件が定まり,必要な機能が見えてきた段階で,ある程度のシステムの規模を概算することが可能.
>>4. 使い勝手<br>
>>      1. 画面の視認性
>>      2. 操作性
>>      3. 入力補助
>>      4. 互換性
>>      5. チュートリアル
># 
<br>

>## 開発プロセス
>>### ウォーターフォール型開発プロセス
>>- 要件定義が完成したら機能設計,機能設計が完成したら詳細設計といったように順々にこなしていくため,進捗管理が容易で,成果物が明確である.
>>- 計画通りにいかなかった部分は,後工程にしわ寄せが集中してしまうリスクがある.
>
>>### スパイラルモデル
>>- プログラム開発を小さなフェーズに分割して行う.
>>- フェーズごとにプロトタイプ,提案,評価,フィードバックの4つの工程を繰り返す.
>>- プロトタイプを作成する際に,想定外の作業量を伴う可能性がある.
>
>>### 反復型開発プロセス
>>ソフトウェアを機能ごとに分割して,それらを反復という単位で管理する手法.<br>
>>- メリットとして,部分的に完成させていくため,顧客の要求に対応しやすい.また部分的に納品することも可能.<br>
>>- デメリットとして,作業や管理業務の増加,全体像の見えづらさ,一括して稼働するシステムでは意味がないなどが挙げられる.
>
>>### アジャイルプロセス
>>アジャイル(agile)とは機敏,俊敏といったように,ウォーターフォール型開発プロセスでは想定されていなかった,できるだけ決定を遅らせ,できるだけ早く提供するということを実現したモデル.変化に対応し,最適な手法で動作するソフトウェアの提供を優先,またモチベーションを上げ,学習効果を高めることで無駄をなくしている.<br>
>>#### アジャイルの価値
>>- プロセスやツールよりも個人の相互作用.
>>- 分かりやすいドキュメントよりも,動作するソフトウェア.
>>- 契約上の駆け引きよりも,顧客と協力して共に進めていく.
>>- 計画通りではなく,変化に対応.
>>#### アジャイルのコンセプト
>>- 変化に対する柔軟性.
>>- 俊敏なサイクル,頻繁な納期.
>>- シンプルさ
>>- リファクタリング
>>- ペアプログラミング
>>- レトロスペクティブ
>>- 暗黙知の活用
>>- テスト駆動型開発
>
>>### アジャイル開発の12の原則
>>1. ソフトウェアの早期,継続的な納品によって顧客の満足度を達することが最優先である.
>>2. いついかなる時も要求内容の変更を歓迎する.アジャイルなプロセスは顧客の競争上の優位性のために変化を制する.
>>3. 数週間から数ヵ月といったように,短いサイクルでソフトウェアを納品する.
>>4. ビジネス側の人間も,開発者も日々協力してプロジェクトを進めなければならない.
>>5. 志の高い人間がチームの中心となりプロジェクトを編成する.必要な環境や資源を与え,任務をやり遂げることを信じること.
>>6. 開発チームの内外で情報伝達を行う際には,顔を突き合わせることが最も効率的で効果的である.
>>7. 動作するソフトウェアが主な進捗確認の方法である.
>>8. アジャイルなソフトウェア開発は,持続的な開発を促す.開発資金の提供者,開発者,ユーザは,必ず一定のペースを守るべきである.
>>9. 機敏さ向上のために,技術力とよい設計に絶えず気を配ること.
>>10. その本質には,不必要なことは行わないという簡潔さが存在している.
>>11. 最新のアーキテクチャ,要求,設計は,自己組織化されたチームから生まれる.
>>12. 定期的に,チームでもっと効率的になる道を考え,開発の進み方を見直し,調整する.<br>
>### どの開発手法がよいのか
>開発手法それぞれにメリット,デメリットは存在しており,一長一短である.場面,要求からもっとも適した手法を用いることが重要である.
<br>

>## WBS(Work Breakdown Structure)
>WBSとは,プロジェクトの目標を達成し,必要な要素成果物を生成するために,プロジェクトチームが実行すべき作業をあらかじめ階層的に要素分解したものである.
>#### メリット
>- スコープが明確になる.
>- やるべき作業が明確になる.
>- 全体管理と作業計画が明確化される.
>- プロジェクトを実行する際は,WBSに従って実行するのみ.
>>### WBSの作り方
>>- トップダウンアプローチとバックキャスティングからスコープを明確にする.
>>- 大きな作業は分割し,グループごとにまとめる.
>>- グルーピングした作業の相互関連を考える.
>>- もれなくダブりなく各グループの作業を全て洗い出す.
># 
<br>

>## コーディング
>コードは**書くよりも読まれることが多い**ため,ソフトウェア開発において読みやすいコードを書くことは必須である.他人が読みやすいコード,未来の自分が読みやすいコードを書く方法として,様々なルールが存在している.
>## PEP8
>ルールの1つとしてPythonのPEP8がある.以下はそのルール内容である.
>>### 一行の長さ
>>コードの一行の長さは79文字以内とし,docstringやコメントは72文字以内とする.行を継続する場合は,折り返された要素を縦に揃える.
>>### レイアウト
>>1レベルインデントするごとに,スペースを4つ使い間を空ける.
>>### スペース
>>演算子の前後にはスペースを1つずつ空ける.また無駄なスペースを空けない.
>>### 改行
>>文を重ねて書かずに,改行する.また演算子を用いる文で改行する場合,その演算子の位置を合わせる.
>>### import
>>1. 標準ライブラリ
>>2. サードパーティに関連する物
>>3. ローカルなアプリケーションまたはライブラリに特有なもの
>>### コメント
>>- コードと矛盾するようなコメントは書かない.
>>- コメントは複数の完全な文で書く.またはじめの単語はそれが小文字で始まるものでない限り大文字にするべきである.
>>- コメントが2つ以上の文からなる場合,文の終わりのピリオドの後に2つスペースを空けるべきである.ただし最後の文は除く.
>>- 書いている言語の他の話者からしても分かりやすいものにする.
>>- あなたのコードが自分の言語を話さない人に絶対に読まれることがない限り,コメントは英語で書くことが推奨される.
>>### 命名規則
>>- パッケージ<br>
>>全て小文字の短い名前,アンダースコアは使わない.
>>- モジュール<br>
>>全て小文字の短い名前,アンダースコアで区切ってもよい.
>>- クラス,例外<br>
>>CapWords方式 (先頭だけ大文字の単語を繋げる,アンダースコアは使わない).
>>- 関数,メソッド<br>
>>小文字のみ,必要に応じて単語をアンダースコアで区切る.
>>- 定数<br>
>>大文字のみ,単語をアンダースコアで区切る.通常,モジュールレベル(関数の外側)に書く.
>>- 変数,引数<br>
>>小文字のみ,必要に応じて単語をアンダースコアで区切る.
>>- 1文字変数<br>
>>l (小文字のエル),O (大文字のオー),I(大文字のアイ) は決して使わない.(フォントによって数字の1、0と見分けがつかないため)
>>### その他
>>- UTF-8以外のエンコーディングはあまり使わない方が良い.
>>- ASCII文字以外の使用を極力避ける.
>>- PEP8のスタイルガイドに合わせることは重要だが,プロジェクトの中で一貫性を保つことはもっと重要
># 
<br>

>## バージョン管理
>ファイルを「**誰が**」,「**いつ**」,「**どのように**」変更したかを記録することで,多数のメンバーと共同でコード開発を行うことが可能となる.
>>### 集中管理型
>>- リモートレポジトリのみがバージョン管理を行う.
>>- 同時編集するとコンフリクトが発生しやすい.
>>- 同期に時間がかかってしまう.
>>### 分散管理型
>>- リモートレポジトリの他にローカルレポジトリでもバージョン管理を行う.
>>- リモートレポジトリへのアクセス頻度が低い.
>>- 一部で障害を起こしても,システム全体に影響を与えることはないため,障害に強い.
># 
<br>

>## git
>gitは分散管理型のバージョン管理システムである.変更履歴が残り,変更した箇所に戻ることもでき,他人と共同編集を行うことができる.
>>### コミット
>>ファイルの作成,変更,削除の記録のことであり,いつ,誰が,なにを,どのように変更したかを記録する.対象ファイルは1つでも複数でもよい,またコミットの単位はユーザが自由に決めることできる.
>>### レポジトリ
>>gitが管理するプロジェクトのフォルダのこと.
>>- ローカルレポジトリ
>>   - 個々のプロジェクト実行環境.
>>- リモートレポジトリ
>>   - 共有の管理場所.(GithubやGitlabなど)
>>### ワークツリー
>>- untracked
>>   - gitで管理されていないファイルの状態.
>>- unmodified
>>   - gitで管理されているが,変更されていないファイルの状態.
>>- modified
>>   - gitで管理されていて,変更されたファイルの状態.
>>### ブランチ
>>作業を枝分かれさせることで,共同作業やへ移行作業が可能となる.
>>### ローカルレポジトリでの流れ
>>1. 変更したファイルをコミットするために,ファイルをステージングエリアに追加する.(git add)
>>2. コミットにより変更を記録する.(コミットされたファイルはunmodifiedの状態になる)
>>### リモートレポジトリでの流れ
>>1. ローカルレポジトリで変更された内容をリモートレポジトリへ反映する.(git push)
>>2. リモートレポジトリにある内容をローカルレポジトリに反映する.(git pull)
># 
<br>

>## Github
>Githubとは,リモートレポジトリのホスティングサービスの1つで,オープンソースソフトウェアの主要なポータルサイトとなっている.
>>### Githubでのソフトウェアエンジニアリング
>>- forkすることで,他ユーザのリモートレポジトリの内容を,自分のリモートレポジトリに反映することが可能(templateを用いると複数forkすることが可能.)
>>- cloneでリモートレポジトリにある内容を,ローカルレポジトリに反映することが可能.
>>- issuesという機能では,レポジトリに関する問題,課題,バグ,機能追加や質問などを挙げることが可能.
># 
<br>

>## CI/CD
>**Continuous Integration**(CI)とは,コード変更を共有レポジトリに頻繁に統合するプロセスのことである.自動テストとビルドの定期的な実行により,バグの早期発見と修正を可能にし,CIを自動化することでスムーズな開発進行を促進している.<br>
>**Continuous Delivery**(CD)とは,コード変更をテスト,本番環境に自動的にデプロイするプロセスのことである.自動デプロイメントにより,手動操作によるデプロイの必要性を排除し,CDにより,ユーザフィードバックを迅速に反映可能にしている.
>>### CI/CDパイプラインの基本的なステップ
>>1. ソース<br>
>>コード変更をトリガーにワークフローを起動.
>>2. ビルド<br>
>>ソースコードをコンパイル.
>>3. テスト<br>
>>自動テストを実行.
>>4. デプロイ<br>
>>テスト済みのコードを本番環境にデプロイ.
>>5. 検証<br>
>>デプロイされたアプリケーションの動作確認.
>>6. モニタリング<br>
>>本番環境での継続的な監視.
>>### Github Actionsを使用したCI/CD
>>1. ワークフローの定義<br>
>>YAMLファイルで定義し,.github/workflows/ディレクトリに配置する.イベント,ジョブ,ステップで構成されている.
>>2. トリガー<br>
>>プッシュやプルリクエスト,スケジュールなど様々なイベントでワークフローを実行可能.
>>3. ジョブとステップ<br>
>>ジョブは並列実行,ステップではシェルコマンドの実行やアクションの使用が可能.
>>4. アクション<br>
>>再利用可能なワークフローの構成要素のこと.コミュニティが作成したアクションも利用可能.
>>5. ランナー<br>
>>Github提供のホステッドランナー,またはセルフホステッドランナーを使用可能.
>>### CI:flake8の適用
>>- ymlは設定ファイルであり,XMLやJSONと比べてシンプルで読みやすい構文.
>>- インデントを使って階層構造を表現,スペースによってインデントを実現することが重要.
>>- キーと値をコロン(:)でペアとして情報を表現.
>>- リスト形式のデータはハイフン(-)で表現.
>>- name<br>
>>ワークフローの名前を定義.
>>- on<br>
>>トリガーイベントを定義.
>>- jobs<br>
>>"syntax-check"というジョブを定義
># 
<br>

>## CI/CDの実践(Github pages)
>Github pagesでは,Githubにあるリモートレポジトリの内容をWebページとして公開することが可能.HP更改はCI/CDにより自動化されている.またJekyllを使用することでmarkdownファイルを自動でhtml化することができるため,開発者はmarkdownファイルを作成するだけでよい.